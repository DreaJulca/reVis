# Get just section 2 data - short-term solution
rm(list=ls())

library(data.table)
library(parallel)
library(rvest)
library(httr)
#As it turns out, SQL-type queries are so much faster!
library(RODBC)
library(ggplot2)
#library(xlsx)
#library(rattle)



userID <- Sys.info()[[7]]
myPath <- paste0('C:/Users/', userID, '/GitHub/Documents/reVis/')

#Actually, these aren't really needed
#dir.create(myPath)
#dir.create(paste0(myPath, 'xls/'))
#dir.create(paste0(myPath, 'xls/NIPA/'))
#dir.create(paste0(myPath, 'csv/'))
#dir.create(paste0(myPath, 'csv/NIPA'))


archive <- 'http://www.bea.gov/histdata/histChildLevels.cfm?HMI=7'

links <- read_html(archive) %>% html_nodes('a') 

dataLinks <- paste0(
	'http://www.bea.gov/histdata/', 
	links[
		grepl(
			'fileStructDisplay.cfm?HMI=7&amp;DY=', 
			links, 
			fixed=T
		)
	] %>% 
		html_attr('href')
)

cl <- makePSOCKcluster(3*detectCores())
clusterEvalQ(cl, library(rvest))
clusterEvalQ(cl, library(data.table))
clusterExport(cl, 'dataLinks')

dlLinks <- parLapply(cl, dataLinks, function(thisLink){
	#test
	#thisLink <- dataLinks[1]
	thisPage <- read_html(thisLink) 
	theseLinks <- data.table(paste0('http://www.bea.gov',  thisPage %>% html_nodes('td') %>% html_nodes('a') %>% html_attr('href')))
	return(theseLinks)
})

stopCluster(cl)
#Links take form:
#http://www.bea.gov/histdata/Releases/GDP_and_PI/2016/Q1/Second_May-27-2016/UND/Section0ALL_xls.xls

DTLs_all <- rbindlist(dlLinks)
####CHANGE LINE BELOW IF YOU WANT DIFFERENT DATASETS!
DTLs <- DTLs_all[grep('und/section2', tolower(V1), fixed = TRUE)]



cl <- makePSOCKcluster(detectCores())
clusterExport(cl, c('DTLs', 'userID'))
clusterEvalQ(cl, library(data.table))
#As it turns out, SQL-type queries are so much faster!
clusterEvalQ(cl, library(RODBC))
#clusterEvalQ(cl, library(xlsx))
#clusterEvalQ(cl, library(parallel))
#clusterEvalQ(cl, library(rattle))


#reVis <- parLapplyLB(cl, DTLs[, V1], function(thisUrl){
reVis <- parLapply(cl, DTLs[, V1], function(thisUrl){
	#Allow more Java heap space
#	options(java.parameters = "-Xmx1000m")

#reVis <- rbindlist(lapply(DTLs[, V1], function(thisUrl){
	#test
	#thisUrl <- DTLs[, V1][1]
	foldLoc <- paste0(
		'C:/Users/',userID,'/Documents/GitHub/reVis/xls/NIPA',
			strsplit(
				strsplit(
					tolower(thisUrl), 
					'gdp_and_pi', 
					fixed=T)[[1]][2], 
				'section'
				)[[1]][1]
			)
	
	fileLoc <- paste0(
		'C:/Users/',userID,'/Documents/GitHub/reVis/xls/NIPA',
#			strsplit(
#				'section',
				strsplit(
					tolower(thisUrl), 
					'gdp_and_pi', 
					fixed=T)[[1]][2] 
#				)[1]
			)

		loc <- regexpr('NIPA', fileLoc)[1]

		yrFold <- substr(foldLoc, 1, loc+8)
		qtFold <- substr(foldLoc, 1, loc+12)
		
		
		yrFoldC <- gsub('reVis/xls', 'reVis/csv', yrFold, fixed=T)
		qtFoldC <- gsub('reVis/xls', 'reVis/csv', qtFold, fixed=T)
		foldLocC <- gsub('reVis/xls', 'reVis/csv', foldLoc, fixed=T)
		#A sort of intermediate location - 
		# won't actuall exist, but we'll use it later for each sheet
		fileLocC <- gsub('reVis/xls', 'reVis/csv', fileLoc, fixed=T)
#We want to do this for CSV area, too
	try(
	if(foldLoc != paste0('C:/Users/',userID,'/Documents/GitHub/reVis/xls/NIPANA')){
			
		#Creates folders if needed
		dir.create(foldLoc, showWarnings = FALSE, recursive = TRUE)
		dir.create(foldLocC, showWarnings = FALSE, recursive = TRUE)

		
		#Store a local copy if it hasn't already been stored
		if(!file.exists(fileLoc)) {download.file(thisUrl, fileLoc, mode = 'wb');}

		vint <- gsub('/', '', substr(qtFold, loc+4, loc+12), fixed=T);
		rCyc <- ifelse(
			nchar(gsub('advance', '', tolower(foldLoc), fixed=T)) < nchar(foldLoc),
			'1', ifelse(
				nchar(gsub('second', '', tolower(foldLoc), fixed=T)) < nchar(foldLoc),
					'2', '3'
				)
			);

	
		#Create connection (using odbcConnectExcel2007 if extension is not .xlsx)
		if(tolower(substr(fileLoc, nchar(fileLoc)-1, nchar(fileLoc))) == 'x'){
			conn <- odbcConnectExcel(fileLoc)
		} else {
			conn <- odbcConnectExcel2007(fileLoc)
		}
		myTabs <- sqlTables(conn)$TABLE_NAME
		dataTabs <- gsub("'", "", myTabs[substr(tolower(myTabs), 1, nchar('contents')) != 'contents'], fixed=T)
		
#Parallelizing on all cores causes failure... this may be where we WANT to use it, though, since reading from xlsx takes 4eva.
#Problem: This doesn't seem to respect the sequential nature of lapply...
#		cl <- makePSOCKcluster(detectCores()/2)
#		clusterExport(cl, c('fileLoc', 'sht'))
#		clusterEvalQ(cl, library(xlsx))
#		fillerList <- parLapply(cl, sht, function(thisSht){
		fillerList <- lapply(dataTabs, function(thisTab){
				#rename this so that it's not the same as tbl		
			csvLoc <- gsub(
				'.xls', 
				paste0('_',thisTab,'.csv'), 
				tolower(fileLocC), 
				fixed=T
			)

			if(file.exists(csvLoc)){
				return('')
			} else {
			tryCatch({
				write.csv(
					sqlQuery(conn, paste0("select * from ['", thisTab, "']")), 
					file = gsub('.xlsx', '.csv',	csvLoc, fixed=T)
				)
			 }, 
				error = function(e) {try(
					write.csv(
						sqlQuery(conn, paste0("select * from ['", thisTab, "']")), 
						file = gsub('.xlsx', '.csv',	csvLoc, fixed=T)
					)
				)},
			 finally = {
				return('')
			})
		}
		})
#		stopCluster(cl)	
#		try(stopCluster(cl))
	})
	return( as.data.table(list()))
})

stopCluster(cl)



#SEPARATE PARSER


	#If program bombs, just use the XLS area from "Get_BEAhist.r" instead of CSV
	myPath <- paste0('C:/Users/', userID, '/Documents/GitHub/reVis/csv/NIPA')
	
	allFolds <- list.dirs(path = myPath)
	
	allFiles <- rbindlist(lapply(allFolds, function(thisPath){
		theseFiles <- data.table(list.files(path = thisPath, full.names = TRUE));
		return(theseFiles);
	}));
	
	allCSVs <- allFiles[tolower(substr(V1, nchar(V1)-2, nchar(V1))) == 'csv']
	
	csvDpce <- allCSVs[grep('/und/section2all', tolower(V1), fixed = T)]
	
#QUARTERLY DATA first
	qtrDpce <- csvDpce[grep('20405u qtr', tolower(V1), fixed=T)]

	
	cl <- makePSOCKcluster(2*detectCores())
	clusterEvalQ(cl, library(data.table))
	clusterExport(cl, 'csvDpce')
	
	pceQtrHist <- parLapply(cl, qtrDpce[,V1], function(thisFile){
 #In this case, lines 1-6 are meta
# 	 thisFile <-	qtrDpce[,V1][1]

	readDT <- fread(thisFile, header = FALSE)
	if (dim(readDT) == c(1, 1)){
		warning(paste0('Empty file: ', thisFile))
		return(readDT)
	} else {
		cleanDT <- readDT[!is.na(V3)]
		yrs <- t(readDT[8])
		qtr <- t(readDT[9])
		colDates <- paste0(yrs[5:length(yrs)], 'q', qtr[5:length(qtr)])
		tabName <- gsub('#', '.', readDT[1,V2], fixed=T)
		data.table::setnames(cleanDT, c(
			'XLS_Line', 
			'LineNumber', 
			'LineDescription', 
			'SeriesCode', 
			colDates
		))
		 #Just return filename.  We'll use it later to do vintaging
		cleanDT[, FileName := thisFile]
		cleanDT[, TableName := tabName]
		cleanDT[, LineNumber := as.numeric(LineNumber)]
		fnlDT <- cleanDT[!is.na(LineNumber)]
		
		return(fnlDT)
	}
})

stopCluster(cl)

#memory.limit(size = 4095)

pceDTq <- rbindlist(pceQtrHist, fill=T, use.names=T)
qNames <- attributes(pceDTq)$names

pceDTq[, Vin := tolower(gsub('/', '', substr(FileName,  regexpr('NIPA', FileName)[1]+4,regexpr('NIPA', FileName)[1]+15), fixed=T))]
pceDTq[grep('pre', Vin, fixed = T), Vin := gsub('pre', 'sec', Vin, fixed = T)] 
pceDTq[grep('fin', Vin, fixed = T), Vin := gsub('fin', 'thi', Vin, fixed = T)] 
pceDTq[
	!is.na(SeriesCode) & gsub(' ', '', SeriesCode) != '',  
	Code := ifelse(
		substr(SeriesCode, 1, 1) == 'E',
		substr(SeriesCode, 3, 5),
		substr(SeriesCode, 2, 4)
	)] 

pceDTq[!is.na(Code)]
#Gives us 2004Q3 advance estimate; need to use generalizable method for this
pceDTq[Vin == '2004q3adv', .(LineNumber, LineDescription, SeriesCode, `2004q3`)]


#Find available periods where there is both an advance and a third estimate
#This was my original approach, but there are more second estimates than I thought
qVinAv <- sort(unique(pceDTq[, Vin]))
qtrsAv <- sort(unique(pceDTq[, substr(Vin, 1, 6)]))
qAdvAv <- paste0('`', substr(sort(unique(pceDTq[substr(Vin, 7, 9) == 'adv', Vin])), 1, 6), '`')
qSecAv <- paste0('`', substr(sort(unique(pceDTq[substr(Vin, 7, 9) == 'sec', Vin])), 1, 6), '`')
qThiAv <- paste0('`', substr(sort(unique(pceDTq[substr(Vin, 7, 9) == 'thi', Vin])), 1, 6), '`')

qAvail <- qAdvAv[qAdvAv %in% qThiAv]


outDT <- rbindlist(lapply(2:length(qtrsAv), function(indx){
	#test
	# indx <- 2
	thisQtr <- qtrsAv[indx]
	prevQtr <- qtrsAv[(indx-1)]
	
	thisAdv <- unique(pceDTq[
		Vin == paste0(thisQtr, 'adv'), 
		.(
			Code, 
			AdvLvl = eval(
				parse(
					text=paste0('as.numeric(`', thisQtr, '`)')
				)
			), 
			AdvPct = eval(
				parse(
					text=paste0('(as.numeric(`', thisQtr, '`)/as.numeric(`', prevQtr, '`))-1')
				)
			)
		)
	])
	
	thisSec <- unique(pceDTq[
		Vin == paste0(thisQtr, 'sec'), 
		.(
			Code, 
			SecLvl = eval(
				parse(
					text=paste0('as.numeric(`', thisQtr, '`)')
				)
			), 
			SecPct = eval(
				parse(
					text=paste0('(as.numeric(`', thisQtr, '`)/as.numeric(`', prevQtr, '`))-1')
				)
			)
		)
	])

	thisThi <- unique(pceDTq[
		Vin == paste0(thisQtr, 'thi'), 
		.(
			Code, 
			ThiLvl = eval(
				parse(
					text=paste0('as.numeric(`', thisQtr, '`)')
				)
			), 
			ThiPct = eval(
				parse(
					text=paste0('(as.numeric(`', thisQtr, '`)/as.numeric(`', prevQtr, '`))-1')
				)
			)
		)
	])

	data.table::setkey(thisAdv, key = Code)
	data.table::setkey(thisSec, key = Code)
	data.table::setkey(thisThi, key = Code)

	thisDT <- thisAdv[thisSec[thisThi]]
	thisDT[,TimePeriod := thisQtr]
	
	return(thisDT)

}), use.names=TRUE)

write.csv(outDT, file=paste0('c:/Users/', userID, '/Documents/GitHub/reVis/ajax/tab245u_vin.csv'), row.names = FALSE)

#MONTHLY DATA now
	cl <- makePSOCKcluster(2*detectCores())
	clusterEvalQ(cl, library(data.table))
	clusterExport(cl, 'csvDpce')
	
	monDpce <- csvDpce[grep('20405u mon', tolower(V1), fixed=T)]

	pceMonHist <- parLapply(cl, monDpce[,V1], function(thisFile){
 #In this case, lines 1-6 are meta
# 	 thisFile <-	monDpce[,V1][1]

	readDT <- fread(thisFile, header = FALSE)
	if (dim(readDT) == c(1, 1)){
		warning(paste0('Empty file: ', thisFile))
		return(readDT)
	} else {
		tabStarters <- unique(readDT[tolower(V2) == "line",V1])
		myMonTab <- lapply(tabStarters, function(tabStr){
		# tabStr <- tabStarters[3]
			cleanDT <- readDT[!is.na(V3) & V1 >= tabStr]
			yrs <- t(readDT[as.numeric(V1) == as.numeric(tabStr)])
			mon <- t(readDT[as.numeric(V1) == as.numeric(tabStr)+1])
			colDates <- paste0(yrs[5:length(yrs)], 'm', mon[5:length(mon)])
			tabName <- gsub('#', '.', readDT[1,V2], fixed=T)
			data.table::setnames(cleanDT, c(
				'XLS_Line', 
				'LineNumber', 
				'LineDescription', 
				'SeriesCode', 
				colDates
			))
			 #Just return filename.  We'll use it later to do vintaging
			cleanDT[, FileName := thisFile]
			cleanDT[, TableName := tabName]
			cleanDT[, LineNumber := as.numeric(LineNumber)]
			thisDT <- cleanDT[!is.na(LineNumber)]
			data.table::setkey(thisDT, key=LineNumber, 
				SeriesCode, 
				FileName, 
				TableName, 
				LineDescription
			)
			eval(parse(text=paste0('thisDTback <- unique(thisDT[,
			.(
				XLS_Line, 
				LineNumber, 
				LineDescription, 
				SeriesCode, 
				FileName, 
				TableName, 
				', 
				paste(
					sort(paste0(
						'`',
						colDates[colDates != 'NAmNA'],
						'`'
					)), 
					collapse = ',' 
				), 
				')])'
			)))
				
			data.table::setkey(thisDTback, key=LineNumber, 
				SeriesCode, 
				FileName, 
				TableName, 
				LineDescription
			)
			return(thisDTback)
		})
		fnlDT <- Reduce(merge, myMonTab)

		
		return(fnlDT)
	}
})

stopCluster(cl)

#memory.limit(size = 4095)

pceDTm <- rbindlist(pceMonHist, fill=T, use.names=T)
mNames <- attributes(pceDTm)$names

pceDTm[, Vin := tolower(gsub('/', '', substr(FileName,  regexpr('NIPA', FileName)[1]+4,regexpr('NIPA', FileName)[1]+15), fixed=T))]
pceDTm[grep('pre', Vin, fixed = T), Vin := gsub('pre', 'sec', Vin, fixed = T)] 
pceDTm[grep('fin', Vin, fixed = T), Vin := gsub('fin', 'thi', Vin, fixed = T)] 
pceDTm[
	!is.na(SeriesCode) & gsub(' ', '', SeriesCode) != '',  
	Code := ifelse(
		substr(SeriesCode, 1, 1) == 'E',
		substr(SeriesCode, 3, 5),
		substr(SeriesCode, 2, 4)
	)] 

pceDTm[!is.na(Code)]
#Gives us 2004Q3 advance estimate; need to use generalizable method for this
pceDTm[Vin == '2004q3adv', .(LineNumber, LineDescription, SeriesCode, `2004m9`)]

#Let's create some columns that will allow us to get the vintages we want
#Month of release
pceDTm[,ReleaseMonth := gsub('q1adv', 'm04', Vin)]
pceDTm[,ReleaseMonth := gsub('q1sec', 'm05', ReleaseMonth)]
pceDTm[,ReleaseMonth := gsub('q1thi', 'm06', ReleaseMonth)]
pceDTm[,ReleaseMonth := gsub('q2adv', 'm07', ReleaseMonth)]
pceDTm[,ReleaseMonth := gsub('q2sec', 'm08', ReleaseMonth)]
pceDTm[,ReleaseMonth := gsub('q2thi', 'm09', ReleaseMonth)]
pceDTm[,ReleaseMonth := gsub('q3adv', 'm10', ReleaseMonth)]
pceDTm[,ReleaseMonth := gsub('q3sec', 'm11', ReleaseMonth)]
pceDTm[,ReleaseMonth := gsub('q3thi', 'm12', ReleaseMonth)]
pceDTm[,ReleaseMonth := gsub('q4adv', 'm01', ReleaseMonth)]
pceDTm[,ReleaseMonth := gsub('q4sec', 'm02', ReleaseMonth)]
pceDTm[,ReleaseMonth := gsub('q4thi', 'm03', ReleaseMonth)]

#First-release-of month
pceDTm[,AdvMonth := gsub('q1adv', 'm03', Vin)]
pceDTm[,AdvMonth := gsub('q1sec', 'm04', AdvMonth)]
pceDTm[,AdvMonth := gsub('q1thi', 'm05', AdvMonth)]
pceDTm[,AdvMonth := gsub('q2adv', 'm06', AdvMonth)]
pceDTm[,AdvMonth := gsub('q2sec', 'm07', AdvMonth)]
pceDTm[,AdvMonth := gsub('q2thi', 'm08', AdvMonth)]
pceDTm[,AdvMonth := gsub('q3adv', 'm09', AdvMonth)]
pceDTm[,AdvMonth := gsub('q3sec', 'm10', AdvMonth)]
pceDTm[,AdvMonth := gsub('q3thi', 'm11', AdvMonth)]
pceDTm[,AdvMonth := gsub('q4adv', 'm12', AdvMonth)]
pceDTm[,AdvMonth := gsub('q4sec', 'm01', AdvMonth)]
pceDTm[,AdvMonth := gsub('q4thi', 'm02', AdvMonth)]

#Second-release-of month
pceDTm[,SecMonth := gsub('q1adv', 'm02', Vin)]
pceDTm[,SecMonth := gsub('q1sec', 'm03', SecMonth)]
pceDTm[,SecMonth := gsub('q1thi', 'm04', SecMonth)]
pceDTm[,SecMonth := gsub('q2adv', 'm05', SecMonth)]
pceDTm[,SecMonth := gsub('q2sec', 'm06', SecMonth)]
pceDTm[,SecMonth := gsub('q2thi', 'm07', SecMonth)]
pceDTm[,SecMonth := gsub('q3adv', 'm08', SecMonth)]
pceDTm[,SecMonth := gsub('q3sec', 'm09', SecMonth)]
pceDTm[,SecMonth := gsub('q3thi', 'm10', SecMonth)]
pceDTm[,SecMonth := gsub('q4adv', 'm11', SecMonth)]
pceDTm[,SecMonth := gsub('q4sec', 'm12', SecMonth)]
pceDTm[,SecMonth := gsub('q4thi', 'm01', SecMonth)]


#Third-release-of month
pceDTm[,ThiMonth := gsub('q1adv', 'm01', Vin)]
pceDTm[,ThiMonth := gsub('q1sec', 'm02', ThiMonth)]
pceDTm[,ThiMonth := gsub('q1thi', 'm03', ThiMonth)]
pceDTm[,ThiMonth := gsub('q2adv', 'm04', ThiMonth)]
pceDTm[,ThiMonth := gsub('q2sec', 'm05', ThiMonth)]
pceDTm[,ThiMonth := gsub('q2thi', 'm06', ThiMonth)]
pceDTm[,ThiMonth := gsub('q3adv', 'm07', ThiMonth)]
pceDTm[,ThiMonth := gsub('q3sec', 'm08', ThiMonth)]
pceDTm[,ThiMonth := gsub('q3thi', 'm09', ThiMonth)]
pceDTm[,ThiMonth := gsub('q4adv', 'm10', ThiMonth)]
pceDTm[,ThiMonth := gsub('q4sec', 'm11', ThiMonth)]
pceDTm[,ThiMonth := gsub('q4thi', 'm12', ThiMonth)]

#Find available periods where there is both an advance and a third estimate
#This was my original approach, but there are more second estimates than I thought
mVinAv <- sort(unique(pceDTm[, Vin]))
nonMon <- c(
	"LineNumber", 
	"SeriesCode",
	"FileName",
	"TableName",
	"LineDescription",
	"Vin", 
	"Code", 
	"ReleaseMonth", 
	"AdvMonth", 
	"SecMonth", 
	"ThiMonth", 
	"XLS_Line",
	"XLS_Line.x", 
	"XLS_Line.y" 
)

mAdvAv <- paste0('`', sort(unique(pceDTm[, AdvMonth])), '`')
mSecAv <- paste0('`', sort(unique(pceDTm[, SecMonth])), '`')
mThiAv <- paste0('`', sort(unique(pceDTm[, ThiMonth])), '`')

monsAv <- sort(unique(c(mAdvAv, mSecAv, mThiAv)))

mAvail <- mAdvAv[mAdvAv %in% mThiAv]


outDTm <- rbindlist(lapply(2:length(monsAv), function(indx){
	#test
	# indx <- 1
	thisMon <- monsAv[indx]
	prevMon <- monsAv[(indx-1)]
	
	thisAdv <- unique(pceDTm[
		AdvMonth == gsub('`', '', thisMon, fixed=T), 
		.(
			Code, 
			AdvLvl = eval(
				parse(
					text=paste0('as.numeric(', gsub('m0', 'm', thisMon, fixed=T), ')')
				)
			), 
			AdvPct = eval(
				parse(
					text=paste0('(as.numeric(', gsub('m0', 'm', thisMon, fixed=T), ')/as.numeric(', gsub('m0', 'm', prevMon, fixed=T), '))-1')
				)
			)
		)
	])
	
	thisSec <- unique(pceDTm[
		SecMonth == gsub('`', '', thisMon, fixed=T), 
		.(
			Code, 
			SecLvl = eval(
				parse(
					text=paste0('as.numeric(', gsub('m0', 'm', thisMon, fixed=T), ')')
				)
			), 
			SecPct = eval(
				parse(
					text=paste0('(as.numeric(', gsub('m0', 'm', thisMon, fixed=T), ')/as.numeric(', gsub('m0', 'm', prevMon, fixed=T), '))-1')
				)
			)
		)
	])

	thisThi <- unique(pceDTm[
		ThiMonth == gsub('`', '', thisMon, fixed=T), 
		.(
			Code, 
			ThiLvl = eval(
				parse(
					text=paste0('as.numeric(', gsub('m0', 'm', thisMon, fixed=T), ')')
				)
			), 
			ThiPct = eval(
				parse(
					text=paste0('(as.numeric(', gsub('m0', 'm', thisMon, fixed=T), ')/as.numeric(', gsub('m0', 'm', prevMon, fixed=T), '))-1')
				)
			)
		)
	])

	data.table::setkey(thisAdv, key = Code)
	data.table::setkey(thisSec, key = Code)
	data.table::setkey(thisThi, key = Code)

	thisDT <- thisAdv[thisSec[thisThi]]
	thisDT[,TimePeriod := gsub('`', '', thisMon, fixed=T)]
	
	return(thisDT)

}))

write.csv(outDTm, file=paste0('c:/Users/', userID, '/Documents/GitHub/reVis/ajax/tab245u_vin_mon.csv'), row.names = FALSE)

monData <- outDTm
qtrData <- outDT[!(is.na(AdvLvl)|is.na(SecLvl)|is.na(ThiLvl))]

data1intx <- monData[toupper(Code) == 'DUR']
data.table::setkey(data1int, key=TimePeriod)

data1x <- unique(data1intx)
data.table::setkey(data1x, key=TimePeriod)

p1x <- ggplot() + 
  geom_point(data = data1x, aes(x = TimePeriod, y = as.numeric(gsub(',', '', AdvLvl, fixed=T))/1000000, color = "Advance")) +
  geom_point(data = data1x, aes(x = TimePeriod, y = as.numeric(gsub(',', '', SecLvl, fixed=T))/1000000, color = "Second")) +
  geom_point(data = data1x, aes(x = TimePeriod, y = as.numeric(gsub(',', '', ThiLvl, fixed=T))/1000000, color = "Third")) +
  xlab('Month') +
  ylab('Trillions of [current] dollars') + 
	theme(legend.title=element_blank()) + 
	theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
	ggtitle('Durable Goods')

plot(p1x)

#Monthly stuff is messed up right now - stick w/ Qtrs

data2 <-  monData[toupper(Code) == 'NDG']
data.table::setkey(data2, key=TimePeriod)

p2x <- ggplot() + 
  geom_point(data = data2, aes(x = TimePeriod, y = AdvLvl/1000000, color = "Advance")) +
  geom_point(data = data2, aes(x = TimePeriod, y = SecLvl/1000000, color = "Second")) +
  geom_point(data = data2, aes(x = TimePeriod, y = ThiLvl/1000000, color = "Third")) +
  xlab('Month') +
  ylab('Trillions of [current] dollars') + 
	theme(legend.title=element_blank()) + 
	theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
	ggtitle('Nondurable Goods')

plot(p2x)


data3 <-  qtrData[toupper(Code) == 'SER']
data.table::setkey(data3, key=TimePeriod)

p3x <- ggplot() + 
  geom_point(data = data3, aes(x = TimePeriod, y = AdvLvl/1000000, color = "Advance")) +
  geom_point(data = data3, aes(x = TimePeriod, y = SecLvl/1000000, color = "Second")) +
  geom_point(data = data3, aes(x = TimePeriod, y = ThiLvl/1000000, color = "Third")) +
  xlab('Month') +
  ylab('Trillions of [current] dollars') + 
	theme(legend.title=element_blank()) + 
	theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
	ggtitle('Services')

plot(p3x)



p4x <- ggplot(data3) + 
  geom_bar(stat = 'identity', aes(x = TimePeriod, y = SecLvl - AdvLvl, color = "Second vs Adv.")) +
  geom_bar(stat = 'identity', aes(x = TimePeriod, y = ThiLvl - AdvLvl, color = "Third vs Adv.")) +
  xlab('Month') +
  ylab('Revision in Percent Change') + 
	theme(legend.title=element_blank()) + 
	theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
	ggtitle('Services')

plot(p4x)






data1 <-  qtrData[toupper(Code) == 'PCE']
data.table::setkey(data1, key=TimePeriod)

 p1all <- ggplot() + 
  geom_point(data = data1, aes(x = TimePeriod, y = AdvLvl/1000000, color = "Advance")) +
  geom_point(data = data1, aes(x = TimePeriod, y = SecLvl/1000000, color = "Second")) +
  geom_point(data = data1, aes(x = TimePeriod, y = ThiLvl/1000000, color = "Third")) +
  xlab('Month') +
  ylab('Trillions of [current] dollars') + 
	theme(legend.title=element_blank()) + 
	theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
	ggtitle('Personal Consumption Expenditures')

plot(p1all)


#p1 <- ggplot() + 
#  geom_point(data = data1[TimePeriod < '2009m11'], aes(x = TimePeriod, y = AdvLvl/1000000, color = "Advance")) +
#  geom_point(data = data1[TimePeriod < '2009m11'], aes(x = TimePeriod, y = SecLvl/1000000, color = "Second")) +
#  geom_point(data = data1[TimePeriod < '2009m11'], aes(x = TimePeriod, y = ThiLvl/1000000, color = "Third")) +
#  xlab('Month') +
#  ylab('Trillions of [current] dollars') + 
#	theme(legend.title=element_blank()) + 
#	theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
#	ggtitle('Personal Consumption Expenditures')
#
#plot(p1)
#
#
#p2 <- ggplot() + 
#  geom_point(data = data1[TimePeriod >= '2009m11' & TimePeriod < '2013m01'], aes(x = TimePeriod, y = AdvLvl/1000000, color = "Advance")) +
#  geom_point(data = data1[TimePeriod >= '2009m11' & TimePeriod < '2013m01'], aes(x = TimePeriod, y = SecLvl/1000000, color = "Second")) +
#  geom_point(data = data1[TimePeriod >= '2009m11' & TimePeriod < '2013m01'], aes(x = TimePeriod, y = ThiLvl/1000000, color = "Third")) +
#  xlab('Month') +
#  ylab('Trillions of [current] dollars') + 
#	theme(legend.title=element_blank()) + 
#	theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
#	ggtitle('Personal Consumption Expenditures')
#
#plot(p2)
#
#
#p3 <- ggplot() + 
#  geom_point(data = data1[TimePeriod >= '2013m01'], aes(x = TimePeriod, y = AdvLvl/1000000, color = "Advance")) +
#  geom_point(data = data1[TimePeriod >= '2013m01'], aes(x = TimePeriod, y = SecLvl/1000000, color = "Second")) +
#  geom_point(data = data1[TimePeriod >= '2013m01'], aes(x = TimePeriod, y = ThiLvl/1000000, color = "Third")) +
#  xlab('Month') +
#  ylab('Trillions of [current] dollars') + 
#	theme(legend.title=element_blank()) + 
#	theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
#	ggtitle('Personal Consumption Expenditures')
#
#plot(p3)




p4 <- ggplot() + 
  geom_point(data = data1, aes(x = TimePeriod, y = AdvPct, color = "Advance")) +
  geom_point(data = data1, aes(x = TimePeriod, y = SecPct, color = "Second")) +
  geom_point(data = data1, aes(x = TimePeriod, y = ThiPct, color = "Third")) +
  xlab('Month') +
  ylab('Percent Change') + 
	theme(legend.title=element_blank()) + 
	theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
	ggtitle('Personal Consumption Expenditures')

plot(p4)

dataMelt <- melt(data1[,.(Sec_Vs_Adv = SecLvl - AdvLvl, Thi_Vs_Adv = ThiLvl - AdvLvl, TimePeriod)], id.vars='TimePeriod')
ggplot(dataMelt, aes(TimePeriod, value)) +   
  geom_bar(aes(fill = variable), position = "dodge", stat="identity") +
  xlab('Quarter') +
  ylab('Trillions of [current] dollars') + 
	theme(legend.title=element_blank()) + 
	theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
	ggtitle('Personal Consumption Expenditures')

dataMeltPct <- melt(data1[,.(Sec_Vs_Adv = SecPct - AdvPct, Thi_Vs_Adv = ThiPct - AdvPct, TimePeriod)], id.vars='TimePeriod')
ggplot(dataMeltPct, aes(TimePeriod, value)) +   
  geom_bar(aes(fill = variable), position = "dodge", stat="identity") +
  xlab('Quarter') +
  ylab('Percent Change') + 
	theme(legend.title=element_blank()) + 
	theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
	ggtitle('Personal Consumption Expenditures')

rawMeltPct <- melt(data1[,.(Advance = AdvPct, Second = SecPct, Third = ThiPct, TimePeriod)], id.vars='TimePeriod')
ggplot(rawMeltPct, aes(TimePeriod, value)) +   
  geom_bar(aes(fill = variable), position = "dodge", stat="identity") +
  xlab('Quarter') +
  ylab('Percent Change') + 
	theme(legend.title=element_blank()) + 
	theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
	ggtitle('Personal Consumption Expenditures')

  
p5 <- ggplot() + 
  geom_point(data = data1[!(TimePeriod %in% c('2009m11', '2009m12'))], aes(x = TimePeriod, y = SecLvl - AdvLvl, color = "Second vs Adv.")) +
  geom_point(data = data1[!(TimePeriod %in% c('2009m11', '2009m12'))], aes(x = TimePeriod, y = ThiLvl - AdvLvl, color = "Third vs Adv.")) +
  xlab('Month') +
  ylab('Percent Change') + 
	theme(legend.title=element_blank()) + 
	theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
	ggtitle('Personal Consumption Expenditures')

plot(p5)

library(forecast)
pceRev <- as.ts(data1[, .(Thi_Vs_Adv = ThiPct - AdvPct)])
myPath <- paste0('C:/Users/', userID, '/Documents/GitHub/reVis/')

#Should be completely unpredictable to forecast revisions
plot(forecast(pceRev))





#Let's do some mapping w/ API data
#library(beaR)


###############################################
# MARTS reader
###############################################

	martsFiles <- data.table(list.files(path = paste0(myPath, 'csv/marts'), full.names = TRUE));
	
	martsCSVs <- martsFiles[tolower(substr(V1, nchar(V1)-2, nchar(V1))) == 'csv']
	
	t1FromXLS <- martsCSVs[grep('table 1#$.csv', tolower(V1), fixed=T)]
	t1FromTXT <- martsCSVs[grep('table1a.csv', tolower(V1), fixed=T)]
	
	lapply(t1FromXLS[, V1], function(csvTab){
		#test
		# csvTab <- t1FromXLS[,V1][1]
		thisRaw <- fread(csvTab)[, .(tabKey = as.numeric(V1), F1, F2, F10, F11, F12)]
		yrAdv <- thisRaw[grep('kind of business', tolower(F2), fixed=T), F10]
		moAdv <- thisRaw[grep('kind of business', tolower(F2), fixed=T)+1, substr(F10, 1, 3)]
		yrSec <- thisRaw[grep('kind of business', tolower(F2), fixed=T), ifelse(is.na(F11), F10, F11)]
		moSec <- thisRaw[grep('kind of business', tolower(F2), fixed=T)+1, substr(F11, 1, 3)]
		yrThi <- thisRaw[grep('kind of business', tolower(F2), fixed=T), ifelse(is.na(F12), ifelse(is.na(F11), F10, F11), F12)]
		moThi <- thisRaw[grep('kind of business', tolower(F2), fixed=T)+1, substr(F12, 1, 3)]
		nameParts <- thisRaw[is.na(F10)][!is.na(F1)]
		nameParts[, tabKey := tabKey+1]
		cleaner1 <- thisRaw[!is.na(F10)]
		
		data.table::setkey(nameParts, key=tabKey)
		data.table::setkey(cleaner1, key=tabKey)
		
		cleaner2 <- nameParts[cleaner1][tabKey>6]
		cleaner2[, LineDescription := ifelse(is.na(F2), i.F2, paste0(F2, i.F2))]
	})